/*
 * FND.c
 *
 * Created: 2018-12-20 오후 2:37:55
 *  Author: SunKim
 */ 
#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>

void Init_74595(void)
{
	// data pin 		: 아두이노 11, PB3
	// latch clock pin 	: 아두이노 12, PB4
	// shift clock pin 	: 아두이노 13, PB5
	DDRB |= 0b00111000;			// 제어핀 3개를 출력으로 설정
}

void ShiftClock(void)
{
	PORTB |= 0b00100000;			// 이동 클록을 HIGH로
	PORTB &= 0b11011111;			// 이동 클록을 LOW로
}

void LatchClock(void)
{
	PORTB |= 0b00010000;			// 래치 클록을 HIGH로
	PORTB &= 0b11101111;			// 래치 클록을 LOW로
}

void ByteDataWrite(uint8_t data)		// 1 바이트 데이터 출력
{
	for(uint8_t i = 0; i < 8; i++){
		if(data & 0b10000000) 		// MSB부터 1비트 출력
			PORTB |= 0b00001000;
		else
			PORTB &= 0b11110111;
		
		ShiftClock();				// 1비트 출력 후 비트 이동
		data = data << 1;			// 다음 출력할 비트를 MSB로 이동
	}
	
	LatchClock();				// 1바이트 전달 후 실제 출력 발생
}

void WordDataWrite(uint16_t data)		// 1 바이트 데이터 출력
{
	for(uint8_t i = 0; i < 16; i++){
		if(data & 0x8000) 		// MSB부터 1비트 출력
			PORTB |= 0b00001000;
		else
			PORTB &= 0b11110111;
		
		ShiftClock();				// 1비트 출력 후 비트 이동
		data = data << 1;			// 다음 출력할 비트를 MSB로 이동
	}
	
	LatchClock();				// 1바이트 전달 후 실제 출력 발생
}

int main(void)
{
	//{0xFC, 0x60, 0xDA, 0xF2, 0x66, 0xB6, 0xBE, 0xE4, 0xFE, 0xE6};
	uint8_t index = 0;
	//uint16_t numbers[] = 
		//{   
			//0xFCFC, 0xFC60, 0xFCDA, 0xFCF2, 0xFC66, 0xFCB6, 0xFCBE, 0xFCE4, 0xFCFE, 0xFCE6,
			//0x60FC, 0x6060, 0x60DA, 0x60F2, 0x6066, 0x60B6, 0x60BE, 0x60E4, 0x60FE, 0x60E6,
			//0xDAFC, 0xDA60, 0xDADA, 0xDAF2, 0xDA66, 0xDAB6, 0xDABE, 0xDAE4, 0xDAFE, 0xDAE6,
			//0xF2FC, 0xF260, 0xF2DA, 0xF2F2, 0xF266, 0xF2B6, 0xF2BE, 0xF2E4, 0xF2FE, 0xF2E6,
			//0x66FC, 0x6660, 0x66DA, 0x66F2, 0x6666, 0x66B6, 0x66BE, 0x66E4, 0x66FE, 0x66E6,
			//0xB6FC, 0xB660, 0xB6DA, 0xB6F2, 0xB666, 0xB6B6, 0xB6BE, 0xB6E4, 0xB6FE, 0xB6E6,
			//0xBEFC, 0xBE60, 0xBEDA, 0xBEF2, 0xBE66, 0xBEB6, 0xBEBE, 0xBEE4, 0xBEFE, 0xBEE6,
			//0xE4FC, 0xE460, 0xE4DA, 0xE4F2, 0xE466, 0xE4B6, 0xE4BE, 0xE4E4, 0xE4FE, 0xE4E6,
			//0xFEFC, 0xFE60, 0xFEDA, 0xFEF2, 0xFE66, 0xFEB6, 0xFEBE, 0xFEE4, 0xFEFE, 0xFEE6,
			//0xE6FC, 0xE660, 0xE6DA, 0xE6F2, 0xE666, 0xE6B6, 0xE6BE, 0xE6E4, 0xE6FE, 0xE6E6};
	
	uint16_t numbers[] =
	{
		0xFCFC, 0x60FC, 0xDAFC, 0xF2FC, 0x66FC, 0xB6FC, 0xBEFC, 0xE4FC, 0xFEFC, 0xE6FC,
		0xFC60, 0x6060, 0xDA60, 0xF260, 0x6660, 0xB660, 0xBE60, 0xE460, 0xFE60, 0xE660,
		0xFCDA, 0x60DA, 0xDADA, 0xF2DA, 0x66DA, 0xB6DA, 0xBEDA, 0xE4DA, 0xFEDA, 0xE6DA,
		0xFCF2, 0x60F2, 0xDAF2, 0xF2F2, 0x66F2, 0xB6F2, 0xBEF2, 0xE4F2, 0xFEF2, 0xE6F2,
		0xFC66, 0x6066, 0xDA66, 0xF266, 0x6666, 0xB666, 0xBE66, 0xE466, 0xFE66, 0xE666,
		0xFCB6, 0x60B6, 0xDAB6, 0xF2B6, 0x66B6, 0xB6B6, 0xBEB6, 0xE4B6, 0xFEB6, 0xE6B6,
		0xFCBE, 0x60BE, 0xDABE, 0xF2BE, 0x66BE, 0xB6BE, 0xBEBE, 0xE4BE, 0xFEBE, 0xE6BE,
		0xFCE4, 0x60E4, 0xDAE4, 0xF2E4, 0x66E4, 0xB6E4, 0xBEE4, 0xE4E4, 0xFEE4, 0xE6E4,
		0xFCFE, 0x60FC, 0xDAFE, 0xF2FE, 0x66FE, 0xB6FE, 0xBEFE, 0xE4FE, 0xEFFE, 0xE6FE,
	0xFCE6, 0x60E6, 0xDAE6, 0xF2E6, 0x66E6, 0xB6E6, 0xBEE6, 0xE4E6, 0xFEE6, 0xE6E6};
			
	
	Init_74595();				// 74595 초기화
	
	while(1)
	{
		uint16_t pattern = numbers[index];		// 출력 패턴 결정
		//uint8_t pattern = 0xff;		// 출력 패턴 결정
		index = (index + 1) % 100;		// 출력 패턴에서의 위치 결정
		
		WordDataWrite(pattern);		// 바이트 데이터 출력
		
		_delay_ms(1000);
	}
}